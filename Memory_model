// memory_model_fixed2.sv
`timescale 1ns/1ps

// Simple addr-mode enum
typedef enum bit [1:0] { ADDR_AUTO = 2'b00, ADDR_WORD = 2'b01, ADDR_BYTE = 2'b10 } addr_mode_t;

// -----------------------------
// memory_model class (clean & fixed)
// -----------------------------
class memory_model;
  // Members
  bit [31:0] mem_array[];       // dynamic array of 32-bit words
  int unsigned mem_size;        // size in words
  addr_mode_t mode;             // addressing mode
  bit allow_unaligned;          // allow unaligned byte addresses (warn or error depending)

  // Constructor
  function new(int unsigned size_words = 256,
               addr_mode_t addr_mode = ADDR_AUTO,
               bit allow_unaligned_byte = 0);
    if (size_words == 0) begin
      $error("memory_model::new - mem_size must be > 0; using 1");
      size_words = 1;
    end
    mem_size        = size_words;
    mode            = addr_mode;
    allow_unaligned = allow_unaligned_byte;
    mem_array = new[mem_size];
    // initialize
    foreach (mem_array[i]) mem_array[i] = 32'h0;
  endfunction

  // Convert incoming address to word index:
  // returns -1 on error, else returns non-negative index (signed int)
  // override_enable==1 -> use override_mode; else use this->mode
  function int addr_to_index(bit [31:0] addr_input,
                             output bit used_byte_interpretation,
                             input addr_mode_t override_mode,
                             input bit override_enable);
    // Declarations first
    int signed idx;
    int unsigned idxu;
    addr_mode_t use_mode;
    bit unaligned;

    // Initialize outputs
    used_byte_interpretation = 0;
    idx = -1;
    idxu = 0;
    unaligned = 0;

    // Determine mode to use
    if (override_enable) begin
      use_mode = override_mode;
    end else begin
      use_mode = mode;
    end

    // WORD mode: treat address as word index
    if (use_mode == ADDR_WORD) begin
      if (addr_input < mem_size) begin
        idx = int'(addr_input);
        used_byte_interpretation = 0;
        return idx;
      end else begin
        return -1;
      end
    end

    // BYTE mode: treat address as byte address (addr/4)
    if (use_mode == ADDR_BYTE) begin
      idxu = addr_input >> 2; // divide by 4
      unaligned = (addr_input & 32'h3) != 0;
      if (unaligned && !allow_unaligned) begin
        $error("MEM_ADDR_ERROR: Byte address 0x%0h not word-aligned and unaligned addresses not allowed.", addr_input);
        return -1;
      end
      if (idxu < mem_size) begin
        used_byte_interpretation = 1;
        idx = int'(idxu);
        if (unaligned) $warning("MEM_ADDR_WARNING: Byte address 0x%0h not word-aligned; using floor(addr/4) = %0d.", addr_input, idxu);
        return idx;
      end else begin
        return -1;
      end
    end

    // AUTO mode: try word, then byte
    if (use_mode == ADDR_AUTO) begin
      // try as word index first
      if (addr_input < mem_size) begin
        idx = int'(addr_input);
        used_byte_interpretation = 0;
        return idx;
      end
      // try as byte address
      idxu = addr_input >> 2;
      unaligned = (addr_input & 32'h3) != 0;
      if (idxu < mem_size) begin
        used_byte_interpretation = 1;
        idx = int'(idxu);
        if (unaligned) $warning("MEM_ADDR_WARNING: Address 0x%0h not word-aligned; using floor(addr/4) = %0d.", addr_input, idxu);
        return idx;
      end
      // neither works
      return -1;
    end

    // fallback (shouldn't happen)
    return -1;
  endfunction

  // Write task: addr interpreted according to class mode unless override_enable is 1
  // Note: override_enable defaults to 0 (no override). If override_enable==1 then override_mode is used.
  task write(bit [31:0] addr, bit [31:0] data,
             input addr_mode_t override_mode, input bit override_enable);
    // Declarations first
    bit used_byte;
    int idx;

    // Use helper
    idx = addr_to_index(addr, used_byte, override_mode, override_enable);
    if (idx < 0) begin
      $error("MEM_WRITE_ERROR: Address 0x%0h out of bounds (mem_size=%0d words). Mode=%0b override_en=%0b", addr, mem_size, use_mode_to_bits((override_enable ? override_mode : mode)), override_enable);
      return;
    end

    mem_array[idx] = data;
    if (used_byte)
      $display("%0t : MEM_WRITE (byte addr): addr=0x%0h -> word_index=%0d, data=0x%0h", $time, addr, idx, data);
    else
      $display("%0t : MEM_WRITE (word idx): addr=0x%0h, data=0x%0h", $time, addr, data);
  endtask

  // Read function with override_enable convention
  function bit [31:0] read(bit [31:0] addr, input addr_mode_t override_mode, input bit override_enable);
    // Declarations first
    bit used_byte;
    int idx;
    bit [31:0] ret;

    idx = addr_to_index(addr, used_byte, override_mode, override_enable);
    if (idx < 0) begin
      $error("MEM_READ_ERROR: Address 0x%0h out of bounds (mem_size=%0d words). Mode=%0b override_en=%0b", addr, mem_size, use_mode_to_bits((override_enable ? override_mode : mode)), override_enable);
      ret = 32'hdead_beef;
      return ret;
    end

    ret = mem_array[idx];
    if (used_byte)
      $display("%0t : MEM_READ (byte addr): addr=0x%0h -> word_index=%0d, data=0x%0h", $time, addr, idx, ret);
    else
      $display("%0t : MEM_READ (word idx): addr=0x%0h, data=0x%0h", $time, addr, ret);
    return ret;
  endfunction

  // Helper function to print mode bits in error messages
  function automatic bit [1:0] use_mode_to_bits(addr_mode_t m);
    return m;
  endfunction

  // Display a block of memory (by word index)
  task display_memory(int unsigned start_index = 0, int unsigned num_words = 16);
    // Declarations first
    int unsigned end_index;
    int unsigned i;

    if (start_index >= mem_size) begin
      $error("display_memory: start_index 0x%0h out of bounds (mem_size=%0d)", start_index, mem_size);
      return;
    end

    end_index = (start_index + num_words > mem_size) ? mem_size - 1 : (start_index + num_words - 1);
    $display("--- Memory Contents (word index 0x%0h to 0x%0h) ---", start_index, end_index);
    for (i = start_index; i <= end_index; i = i + 1) begin
      $display("  Address 0x%0h: 0x%0h", i, mem_array[i]);
    end
    $display("-------------------------------------");
  endtask

  // Load from hex file (one hex word per line). Returns number loaded.
  function int unsigned load_from_hex_file(string filename);
    // Declarations first
    int unsigned count;
    int fh;
    reg [8*256-1:0] line; // char buffer up to 255 chars
    int r;
    reg [31:0] value;

    count = 0;
    fh = $fopen(filename, "r");
    if (fh == 0) begin
      $display("load_from_hex_file: file '%s' not found (or cannot open)", filename);
      return 0;
    end

    // Read lines until EOF or mem full
    while (!$feof(fh) && (count < mem_size)) begin
      line = "";
      r = $fgets(line, fh); // returns 0 on EOF, else non-zero
      if (r == 0) break;
      // If line starts with "/" skip (simple comment handling)
      if (line[8*1*0 +: 8] == "/") begin
        continue;
      end
      // Try to parse hex (allow optional 0x)
      if ($sscanf(line, "0x%x", value) == 1) begin
        mem_array[count] = value;
        count = count + 1;
        continue;
      end else if ($sscanf(line, "%x", value) == 1) begin
        mem_array[count] = value;
        count = count + 1;
        continue;
      end
      // otherwise ignore the line
    end

    $fclose(fh);
    $display("load_from_hex_file: loaded %0d words (mem_size=%0d)", count, mem_size);
    return count;
  endfunction

endclass

// -----------------------------
// Testbench (everything automatic inside initial to avoid implicit static issues)
// -----------------------------
module testbench;
  initial begin : TB_MAIN
    // local declarations (automatic)
    memory_model mem;
    bit [31:0] r;
    string fname;
    int unsigned loaded;

    $display("\n--- memory_model_fixed2 demo starting ---\n");

    // instantiate with 1024 words and AUTO mode, allow unaligned addresses
    mem = new(1024, ADDR_AUTO, 1);

    // Word-index writes
    mem.write(0,   32'h1234_5678, ADDR_AUTO, 0);
    mem.write(4,   32'hABCD_EF01, ADDR_AUTO, 0);
    mem.write(100, 32'hFEED_FACE, ADDR_AUTO, 0);

    // Read back
    r = mem.read(0, ADDR_AUTO, 0);
    r = mem.read(4, ADDR_AUTO, 0);
    r = mem.read(100, ADDR_AUTO, 0);

    // Byte-addressed write (2000 decimal -> 2000/4 = 500). Using AUTO (no override).
    mem.write(2000, 32'hFFFF_FFFF, ADDR_AUTO, 0);
    r = mem.read(2000, ADDR_AUTO, 0);

    // Unaligned address (1003 -> floor(1003/4)=250). We allowed unaligned, so it will warn
    mem.write(1003, 32'hDEAD_BEEF, ADDR_AUTO, 0);
    r = mem.read(1003, ADDR_AUTO, 0);

    // (Removed the explicit forced out-of-bounds word-index write and the explicit OOB read.)

    // Treat small address explicitly as BYTE (0 -> index 0) using override_enable=1
    mem.write(0, 32'hCAFEBABE, ADDR_BYTE, 1);
    r = mem.read(0, ADDR_BYTE, 1);

    // Display first 16 words
    mem.display_memory(0, 16);

    // Attempt to load file (optional) - set fname to your file path if available
    fname = "init_mem.hex";
    loaded = mem.load_from_hex_file(fname);
    if (loaded > 0) mem.display_memory(0, (loaded > 16) ? 16 : loaded);

    $display("\n--- memory_model_fixed2 demo finished ---\n");
    $finish;
  end
endmodule
